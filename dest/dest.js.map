{"version":3,"sources":["webpack:///webpack/bootstrap f375bcff7a79ff6a2855","webpack:///./default.js","webpack:///./imagecompute/main.js","webpack:///./imagecompute/charts.js","webpack:///./imagecompute/worker.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;ACtCA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,qBAAoB,2BAA2B;AAC/C;AACA,sBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,YAAW;AACX;AACA;AACA,mBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;AACA;AACA,IAAG;AACH,eAAc;AACd;AACA,SAAQ,eAAe;AACvB;AACA;AACA;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA,mBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA,IAAG;AACH,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,KAAI;AACJ,IAAG;AACH;AACA;AACA;AACA,kBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,oBAAmB;AACnB;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA,kBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,cAAa;AACb,kBAAiB,6BAA6B;AAC9C;AACA;AACA,IAAG;AACH,+BAA8B;AAC9B,kBAAiB,6BAA6B;AAC9C;AACA;AACA;AACA,IAAG;AACH,uBAAsB;AACtB,kBAAiB,6BAA6B;AAC9C;AACA;AACA;AACA;AACA,IAAG;AACH,mBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,6BAA6B;AAC9C;AACA;AACA;AACA,IAAG;AACH,eAAc;;AAEd;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA,mBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAAyB;AACzB;AACA,KAAI;AACJ;AACA;AACA;AACA,kBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA,kBAAiB,wBAAwB;AACzC;AACA;;AAEA;AACA;AACA;AACA,0BAAyB,UAAU;AACnC,IAAG;AACH,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ,IAAG;AACH;AACA;AACA,4BAA2B,aAAa;AACxC;AACA;AACA,KAAI;AACJ;AACA,KAAI;;AAEJ,6CAA4C;AAC5C,2BAA0B,kCAAkC,OAAO;AACnE,KAAI;;AAEJ,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,QAAO;AACP,kB;AACA;AACA;AACA;;AAEA,uB;;;;;;ACpPA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAM,aAAa;;AAEnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,E;;;;;;ACvDA;AACA;AACA;AACA;AACA,iBAAgB,iBAAiB;;AAEjC;AACA,2CAA0C;AAC1C;AACA,IAAG;AACH;;AAEA,cAAa;AACb;AACA,iBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,sBAAsB;AACtC;AACA;AACA,sCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,E","file":"dest.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f375bcff7a79ff6a2855","\t\tlet Compute =  require('./imagecompute/main.js');\n\n\t\tinit('./1.jpg');\n\n\t\tfunction init(pic) {\n\t\t\tlet State = {\n\t\t\t\tcanvasEle: Object,\n\t\t\t\tctx: Object,\n\t\t\t\timageData: Object\n\t\t\t};\n\t\t\tlet gen;\n\n\t\t\tfunction load(img, el) {\n\t\t\t\tlet {\n\t\t\t\t\theight,\n\t\t\t\t\twidth\n\t\t\t\t} = img;\n\t\t\t\tlet canvasEle = document.createElement(`CANVAS`);\n\t\t\t\tlet ctx = canvasEle.getContext('2d');\n\n\t\t\t\tcanvasEle.height = height;\n\t\t\t\tcanvasEle.width = width;\n\t\t\t\tctx.drawImage(img, 0, 0);\n\t\t\t\tel.appendChild(canvasEle);\n\n\t\t\t\tlet imageData = ctx.getImageData(0, 0, width, height);\n\t\t\t\tState = {\n\t\t\t\t\tcanvasEle,\n\t\t\t\t\tctx,\n\t\t\t\t\timageData\n\t\t\t\t};\n\t\t\t\tgen.next();\n\t\t\t}\n\n\t\t\tfunction* initCanvas(pic,\n\t\t\t\tel = document.getElementsByTagName('BODY')[0]) {\n\t\t\t\tlet img = new Image();\n\t\t\t\timg.src = pic;\n\t\t\t\tyield img.onload = function() {\n\t\t\t\t\tload(img, el)\n\t\t\t\t};\n\t\t\t\t//全局的状态 canvas元素，绘图上下文，图像数据\n\t\t\t\t//进行图片的处理\n\t\t\t\tlet imagedata = Compute.deal(State.imageData);\n\t\t\t\t//clear\n\t\t\t\tState.ctx.clearRect(0,0,State.imageData.width,State.imageData.height);\n\t\t\t\t//调整大小\n\t\t\t\tState.canvasEle.height = imagedata.height;\n\t\t\t\tState.canvasEle.width = imagedata.width;\n\t\t\t\tState.ctx.putImageData(imagedata,0,0,0,0,imagedata.width,imagedata.height);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgen = initCanvas(pic);\n\t\t\tgen.next();\n\t\t}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./default.js\n// module id = 1\n// module chunks = 0","\tlet charts = require('./charts');\n\tlet worker = require('./worker');\n\tmodule.exports = {\n\t\timagedata:Array,//原始图像数组\n\t\tgrayimage:Array,//灰度之后的图像数组,失去rgba信息,不能直接输出为图像\n\t\ttwoDime:Array,//二维的图像像素数组，不能直接输出为图像\n\t\tdeal(imagedata) {\n\t\t\tthis.imagedata = imagedata;\n\n\t\t\t//给imagedata 加上set get 方法\n\t\t\t//TODO\n\n\t\t\tlet that = this;\n\t\t\tlet pre = ['toGray','createWorkers'];\n\t\t\tpre.forEach(function(e){\n\t\t\t\tthat[e]();\n\t\t\t});\n\t\t\t// this.toRawData(this.twoDime);\n\t\t\t// this.powerChange(1);\n\t\t\t// this.log(0.9);\n\t\t\t// this.bitmap(6);\n\t\t\t// let del = this.operImageData(0,this.imagedata,this.imagedata.width,this.imagedata.height/2);\n\t\t\t// for(let i = 0;i< this.imagedata.height/2;i++){\n\t\t\t\t// del.next(i);\n\t\t\t\t// for(let j = 0;j<this.imagedata.width;j++){\n\t\t\t\t\t// del.next(j+i*this.imagedata.width);\n\t\t\t\t// }\n\t\t\t// }\n\t\t\t// this.imagedata = del.next(true).value;\n\t\t\treturn this.imagedata;\n\t\t},\n\t\ttoGray(){//灰度\n\t\t\tlet imagedata = this.imagedata;\n\t\t\tthis.grayimage = [];\n\t\t\tfor (let i = 0; i < imagedata.data.length;) {\n\t\t\t\tlet gray = (imagedata.data[i] * 30 + imagedata.data[i + 1] * 59 + imagedata.data[i + 2] * 11) / 100;\n\t\t\t\tgray = parseInt(gray);\n\t\t\t\timagedata.data[i] = gray;\n\t\t\t\timagedata.data[i + 1] = gray;\n\t\t\t\timagedata.data[i + 2] = gray;\n\t\t\t\tthis.grayimage.push(gray);\n\t\t\t\ti = i + 4;\n\t\t\t}\t\n\t\t\treturn imagedata;\n\t\t},\n\t\ttoTwoDime(){//一维图像数组转二维\n\t\t\tthis.twoDime = [];\n\t\t\tlet {height , width} = this.imagedata;\n\t\t\tlet row = Math.pow(this.grayimage.length/(height/width),0.5);\n\t\t\tlet column = this.grayimage.length/row;\n\t\t\tlet count = 0;\n\t\t\tfor(let i = 0;i<column;i++){\n\t\t\t\tlet item = [];\n\t\t\t\tthis.twoDime.push(item);\n\t\t\t\tfor(let j = 0;j<row;j++){\n\t\t\t\t\titem.push(this.grayimage[count]);\n\t\t\t\t\tcount+=1;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\ttoRawData(twoDime){//二维图像数组信息同步回原始图像数组\n\t\t\tlet that = this;\n\t\t\tlet count=0;\n\t\t\tthis.imagedata.data\n\t\t\ttwoDime.forEach(function(e,index){\n\t\t\t\te.forEach(function(ee,indexs){\n\t\t\t\t\tthat.imagedata.data[count*4] = ee;\n\t\t\t\t\tthat.imagedata.data[count*4+1] = ee;\n\t\t\t\t\tthat.imagedata.data[count*4+2] = ee;\n\t\t\t\t\tcount+=1;\n\t\t\t\t});\n\t\t\t})\n\t\t},\n\t\t*operImageData (oper,imagedata,width,height){\n\t\t\tlet copyarry = [];\n\t\t\tlet flag = false;\n\t\t\tfor(let i = 0;i<imagedata.data.length;i++){\n\t\t\t\tcopyarry.push(imagedata.data[i]);\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tflag = yield flag;\n\t\t\t\tif(flag === true){\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tif(oper == 0){ //只能4个4个的删\n\t\t\t\t\t\tdelete copyarry[flag];\n\t\t\t\t\t\tdelete copyarry[flag+1]\n\t\t\t\t\t\tdelete copyarry[flag+2]\n\t\t\t\t\t\tdelete copyarry[flag+3]\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//添加像素\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet copyimage = new ImageData(width,height);\n\t\t\tfor(let i = 0;i<copyimage.data.length;i++){\n\t\t\t\tif(copyarry[i]){\n\t\t\t\t\tcopyimage.data[i] = copyarry[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn copyimage;\n\t\t},\n\t\treversal(){//图像反转\n\t\t\tfor(let i = 0;i<this.imagedata.data.length;i++){\n\t\t\t\tthis.imagedata.data[i] =  255 - this.imagedata.data[i];\n\t\t\t}\n\t\t},\n\t\tpowerChange(param,weight=1){//幂次变换\n\t\t\tfor(let i = 0;i<this.imagedata.data.length;i++){\n\t\t\t\tlet newdata = (weight*Math.pow(this.imagedata.data[i]/255,param)*this.imagedata.data[i]);\n\t\t\t\tthis.imagedata.data[i] = newdata<=255?newdata:255;\n\t\t\t}\n\t\t},\n\t\tlog(param,weight=1){//对数变换 parm 是 [0,1]\n\t\t\tfor(let i = 0;i<this.imagedata.data.length;i++){\n\t\t\t\tlet newdata = (weight*Math.log(this.imagedata.data[i]*param+1)/\n\t\t\t\t\tMath.log(this.imagedata.data[i]+1))*this.imagedata.data[i];\n\t\t\t\tthis.imagedata.data[i] = newdata;\n\t\t\t}\n\t\t},\n\t\tbitmap(index=0){//比特分层,输出哪个比特面\n\t\t\tif(index > 7){\n\t\t\t\tthrow(\"invaild\");\n\t\t\t}\n\t\t\tindex = 7 - index;\n\t\t\tlet base = parseInt(10000000,2);\n\t\t\tlet bit = base >> index;\n\t\t\tfor(let i = 0;i<this.imagedata.data.length;i++){\n\t\t\t\tlet newdata = this.imagedata.data[i] & bit;\n\t\t\t\tthis.imagedata.data[i] = newdata;\n\t\t\t}\n\t\t},\n\t\thistogram(){//直方图均衡\n\t\t\t\n\t\t\tfunction getHistogram(grayimages){\n\t\t\t\tlet data = [0];\n\t\t\t\tlet grayimage = grayimages.slice(0);\n\t\t\t\tlet sortArray = grayimage.sort(function(a,b){\n\t\t\t\t\treturn a-b\n\t\t\t\t});\n\t\t\t\tlet len = grayimage.length;\n\t\t\t\tlet last = 0;\n\n\t\t\t\tfor(let i = 1;i<=255;i++){\n\t\t\t\tlet count = sortArray.indexOf(i);\n\t\t\t\t// console.log(count)\n\t\t\t\tif(count == -1){\n\t\t\t\t\tcount = 0;\n\t\t\t\t}else{\n\t\t\t\t\tlet tem = count;\n\t\t\t\t\tcount = count - last;\n\t\t\t\t\tlast =tem;\n\t\t\t\t}\n\t\t\t\tdata[i-1] = count;\n\t\t\t\tlen -= count;\n\t\t\t\t}\n\n\t\t\t\tdata[255] = len;\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\tlet data = getHistogram(this.grayimage);\n\t\t\tnew charts.Histogram({//原图的直方图\n\t\t\t\tdata:data\n\t\t\t});\n\t\t\t//均衡\n\t\t\tlet table = [];\n\t\t\tlet sum=0;\n\t\t\tfor(let i = 0;i<256;i++){\n\t\t\t\tsum += data[i];\n\t\t\t\ttable[i] = parseInt(255*1*sum/this.grayimage.length);\n\t\t\t}\n\t\t\tconsole.log(table)\n\t\t\t//原像素到目标像素的映射 TODO\n\t\t\tfor(let i = 0;i<this.grayimage.length;i++){\n\t\t\t\tthis.grayimage[i] = table[this.grayimage[i]];\n\t\t\t}\n\n\t\t\tdata = getHistogram(this.grayimage);\n\t\t\tconsole.log(charts.Histogram);\n\t\t\tlet fn = charts.Histogram;\n\t\t\tnew charts.Histogram({data:data})\n\t\t},\n\t\tgraytoPic(){//一维的灰度数组转化为图片\n\t\t\tlet that = this;\n\t\t\tlet count = 0;\n\t\t\tthis.grayimage.forEach(function(e){\n\t\t\t\tthat.imagedata.data[count*4] = e;\n\t\t\t\tthat.imagedata.data[count*4+1] = e;\n\t\t\t\tthat.imagedata.data[count*4+2] = e;\n\t\t\t\tcount+=1;\n\t\t\t})\t\n\t\t},\n\t\tcreateCameraVideo(el = document.getElementsByTagName('body')[0]){\n\t\t\tlet video = document.createElement('VIDEO');\n\t\t\tnavigator.getUserMedia({\"video\":true},function(stream){\n\t\t\t\tvideo.src = window.URL.createObjectURL(stream);\n\t\t\t\tvideo.play();\n\t\t\t},function(err){\n\t\t\t\tconsole.log(err);\n\t\t\t});\n\n\t\t\tvideo.addEventListener('play',function(){//抓取视频流,立刻抓取是白屏的\n\t\t\t\tsetTimeout(function(){console.log(getVideoFrame(video))},3000);//处理图像数据\n\t\t\t});\n\n\t\t\tfunction getVideoFrame(video){//获取视频流中的帧\n\t\t\t\tlet canvas = document.createElement('CANVAS');\n\t\t\t\tlet ctx = canvas.getContext('2d');\n\t\t\t\tctx.drawImage(video,0,0,video.clientWidth, video.clientHeight);\n\t\t\t\t//返回图像帧数据\n\t\t\t\tconsole.log(video.height)\n\t\t\t\tel.appendChild(canvas);\n\t\t\t\treturn ctx.getImageData(0,0,video.clientWidth, video.clientHeight);\n\t\t\t}\n\t\t},\n\t\tcreateWorkers(){\n\t\t\t//写一个最简单的测试一下\n\t\t\tlet jsstr = `\n\t\t\t\tonmessage = function(e){\n\t\t\t\t// e.data.m+=1；\n\t\t\t\t}\n\t\t\t\tpostMessage('1');\n\t\t\t`;\n\t\t\tlet w = new worker.Worker([jsstr]);\n\t\t\tlet r = w.receive();\n\t\t\tconsole.log(r.next(function(){\n\t\t\t\tconsole.log(1);\n\t\t\t\t// console.log(e);\n\t\t\t}))\n\t\t\tconsole.log(r.next(function(e){\n\t\t\t\tconsole.log(1);\n\t\t\t\t// console.log(e);\n\t\t\t}))\n\n\t\t\tlet s = w.send();\n\t\t\t// w.receive().next(function(e){\n\t\t\t// \tconsole.log(e);\n\t\t\t// });\n\t\t\ts.next('111');\t\t\t\n\t\t\tconsole.log(s.next('1111'));\n\t\t\t}\n}\n\n// 6212261001026960531\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./imagecompute/main.js\n// module id = 2\n// module chunks = 0","function _init(el = document.getElementsByTagName('body')[0]){\n\t\tlet canvas = document.createElement('CANVAS');\n\t\tcanvas.height = el.height?el.height:600;\n\t\tcanvas.width = el.width?el.width:800;\n\t\tel.appendChild(canvas);\n\t\treturn canvas;\n}\n\nfunction _coordinate(canvas){\n\tlet {width,height} = canvas;\n\n\tlet coor = new Path2D();\n\tcoor.moveTo(0,height);\n\tcoor.lineTo(width,height);\n\tcoor.moveTo(0,height);\n\tcoor.lineTo(0,0);\n\tcoor.closePath();\n\n\tcanvas.getContext('2d').stroke(coor);\n}\n\n/**\n\topt{\n\t\tel:ElementObject,\n\t\tdata:Array\n\t}\n**/\nclass Histogram {\n\tconstructor(opt){\n\t\tthis.canvas = _init(opt.el);\n\t\tthis.ctx = this.canvas.getContext('2d');\n\t\tnew _coordinate(this.canvas);\n\t\tlet data = new Path2D();\n\t\tlet dataMax = Number.NEGATIVE_INFINITY;\n\t\tlet dataMin = Number.POSITIVE_INFINITY;\n\t\tlet dataXStep = opt.data.length > 5 ? this.canvas.width/opt.data.length:80;\n\t\topt.data.forEach(function(e){\n\t\t\tdataMax = e > dataMax?e:dataMax;\n\t\t\tdataMin = e < dataMin?e:dataMin;\n\t\t});\n\t\tconsole.log(dataMax)\n\t\tlet dataYStep = this.canvas.height/dataMax;\n\t\tlet that = this;\n\t\topt.data.forEach(function(e,index){\n\t\t\tdata.moveTo(index*dataXStep,that.canvas.height);\n\t\t\tdata.lineTo(index*dataXStep,that.canvas.height-e*dataYStep);\n\t\t\tdata.lineTo((index+1)*dataXStep,that.canvas.height-e*dataYStep);\n\t\t\tdata.lineTo((index+1)*dataXStep,that.canvas.height);\n\t\t});\n\t\tthis.ctx.stroke(data);\n\t}\n}\n\nmodule.exports= {\n\tHistogram\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./imagecompute/charts.js\n// module id = 3\n// module chunks = 0","//因为worker需要序列化反序列化，并且是无论如何都拷贝数据，所以在传递图像数据的时候开销极大\n//但是通过类似于C++或者rust中的move borrow 我们可以极大的提高数据传递的效率\nclass Worker{\n\tconstructor(jsArray){\n\t\tfor(let i = 0;i<jsArray.length;i++){\n\n\t\t};\n\t\tthis.workers = jsArray.map(function(e) { //根据机器核的数目来确定开的webworker的数目，一个新的worker就是新的线程\n\t\t\treturn new window.Worker(e);\n\t\t});\n\t}\n\n\t*_receive(){//主线程接受来自worker的消息调用fn，生成器函数\n\t\tlet fn = function(){};\n\t\tfor(let i = 0;i< this.workers.length;i++){\n\t\t\tthis.workers[i].onmessage = yield fn;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t*_send(){\n\t\tlet param = {};\n\t\tfor(let i = 0;i<this.workers.length;i++){\n\t\t\t let realparam = yield param;\n\t\t\t  // window.Worker.prototype.postMessage.call(this.workers[i],'11')\n\t\t\tthis.workers[i].postMessage('11');//主线程向worker传递数据,move和borrow\n\t\t}\n\t\treturn 11;\n\t}\n\n\treceive(){\n\t\tlet rece = this._receive();\n\t\treturn rece;\n\t}\n\n\tsend(){\n\t\tlet sen = this._send();\n\t\treturn sen;\n\t}\n\n}\nmodule.exports= {\n\tWorker\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./imagecompute/worker.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}